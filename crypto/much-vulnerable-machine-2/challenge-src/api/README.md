# MVMCryption

## Chall

Medium/Hard crypto

1. break biased nonce ecdsa via jwt
2. recover randstate (via nonces from the ecdsa)
3. factor RSA stuff using bleichenbacher may attack
4. use rsa stuff (for signatures) then cbc padding attack thingy

FLAG: `MVM{l0t5_0f_7h1ng5_4r3_v3ry_wr0ng_h3r3}`

## Deployment
For deployment, hardcode these (for speed and consistency) (you can factor them with the bleichenbacher_may_attack)

```py
def bleichenbacher_may_attack(N: int, e: int) -> RSA:
    # perform bleichenbacher may attack
    # https://www.iacr.org/archive/pkc2006/39580001/39580001.pdf

    B1 = matrix(
        ZZ,
        [
            [1, 0, e],
            [0, 1, (1 - N)],
            [0, 0, e**2],
        ],
    )

    # B1 * W = B2 (see document)
    W = diagonal_matrix(
        [4 * e, int(4 * N.sqrt()), int(e ** QQ(3 / 5) * N ** QQ(2 / 5))]
    )

    B2 = B1 * W
    M = B2.LLL()

    M /= W

    for row in M:
        x, y, z = row
        w = (row * B1.inverse())[-1]

        k, l, dp, dq = var("k,l,dp,dq")

        solutions = solve(
            [y == k * l, z == k + l - 1],
            k,
            l,
            solution_dict=True,
            algorithm="sympy",
            domain="integer",
        )

        if not solutions:
            continue
        print(solutions)

        # the 2 random k values
        k_v, l_v = solutions[0][k], solutions[0][l]

        solutions = solve(
            [w == dp * dq, x == dp * (l_v - 1) + dq * (k_v - 1)],
            dp,
            dq,
            solution_dict=True,
            algorithm="sympy",
            domain="integer",
        )

        assert solutions

        for solution in solutions:
            dp_v, dq_v = solution[dp], solution[dq]
            p = int((e * dp_v + k_v - 1) / k_v)
            if N % p == 0:
                q = N / p
                assert p * q == N
                return int(p), int(q)
```


N=7809795247239535555102847344248465683255098635673711159224572347729500007684676238285547766793262649980474416225174142264791325842272762226562884338389374013545637652141730776060180205504227977444234237425007370239748301067338356101593052773924531155376691530483288687629075474703028803024994723026280496580361505377673291166554467905344652542973041814967696819902948297364159574168196015516495901657310445727236054026818939424919395518532000383965003117554691658834621851496527871715874526147020490577058319275554692153590034475165262351438028949315361100210933868218182380825160101827107722107879399281886892083039

e=105618146366940583031972038918277982154407223084694534264617828613025848445190248675389963120041752261171488164713173723073014397668684264816438766687960961274741582243930555797174864781635847743181067882342699483764137332699550905608277181370675049213404014661481719813461913779838563202940583902463360165969


## Description

I'm too tired to hardcode this rn, so this will have to do:

An attack on

```py
N=688523143067221130310576678030433299220179018554046826414260828335202538472307294645693826898935421220121330056593539117676408522324776752500562498408105073883146248464814842002992758440126678969791109215886740368471788156346985866652507643315770944474225099258054701097122282279035744363082933520075107186856562739606164552473068609425916905813157557337021322302761834701348944325425473390261758367831765363412513305002647367222862420098899004526411107265806310544939637066195819561054971559734353485021543303720148084874436740045856678092435442209545739397064784929051446839207715923110759933482477045250647514277

e=98011239440242166566698900909182478499579591553994012246543489477537261857225746359620806272924221914643114124037819334121515530197013448069167414820829072829060396211285847063664930352380987263284391101868939020557899449512764006655929361614868808424862362572962982195082292181544684702119281913347793415203
```

should also work on remote. (stuff might be flaky)
from __future__ import annotations

import json
from datetime import UTC, datetime, timedelta
from pathlib import Path
from secrets import randbits
from typing import Annotated

from Crypto.Util.number import getPrime, long_to_bytes
from fastapi import Cookie, Depends, HTTPException, Response, status

from mvmcryption.crypto.cipher import SCBCCipher
from mvmcryption.crypto.ecdsa import ECDSA, private_key
from mvmcryption.crypto.jwt import SJWT
from mvmcryption.db.users import User, Users
from mvmcryption.resp import PERMISSION_DENIED

SJWT_TTL = timedelta(minutes=15)


def global_ecdsa(private_key: Annotated[int, Depends(private_key)]) -> ECDSA:
    return ECDSA(private_key)


def global_sjwt(ecdsa: Annotated[ECDSA, Depends(global_ecdsa)]):
    return SJWT(ecdsa)


def create_sjwt(user: User, sjwt: SJWT, expires: datetime | None = None) -> str:
    _expires = expires or (datetime.now(UTC) + SJWT_TTL)
    return sjwt.encode({"sub": user.id, "exp": _expires.isoformat()})


def decode_sjwt(token: str, sjwt: SJWT, users: Users) -> User | None:
    if not token:
        return None
    try:
        decoded = sjwt.decode(token)
    except Exception:
        return None

    if not (
        expiry_str := decoded.get("exp")
    ):  # no expiry -> some token generated by an admin
        return None  # for ~~security~~ budget reasons this is disabled right now # TODO: fix this

    if not isinstance(expiry_str, str):
        return None

    try:
        expiry = datetime.fromisoformat(expiry_str)
    except Exception:
        return None

    if not expiry or expiry <= datetime.now(UTC):
        return None

    user_id = decoded.get("sub")

    if user_id is None:
        return None

    if not isinstance(user_id, int):
        return None

    user = users.find(user_id)

    if user is None:
        return None

    return user


def authorized_user(
    users: Annotated[Users, Depends(Users.dependency)],
    sjwt: Annotated[SJWT, Depends(global_sjwt)],
    response: Response,
    mvmcryptionauthtoken: Annotated[str | None, Cookie()] = None,
):
    user = decode_sjwt(mvmcryptionauthtoken, sjwt, users)
    if not user:
        if mvmcryptionauthtoken:
            response.delete_cookie("mvmcryptionauthtoken")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Unauthorized.",
        )
    return user


def admin_user(user: Annotated[User, Depends(authorized_user)]):
    if not user.is_admin:
        raise PERMISSION_DENIED
    return user


def _aes_key() -> bytes:
    f = Path("/etc/aes-key")
    if not f.exists():
        f.write_bytes(long_to_bytes(randbits(128)))
    return f.read_bytes()


def global_aes(key: Annotated[bytes, Depends(_aes_key)]):
    return SCBCCipher(key)


AuthorizedUser = Annotated[User, Depends(authorized_user)]
AdminUser = Annotated[User, Depends(admin_user)]
GlobalECDSA = Annotated[ECDSA, Depends(global_ecdsa)]
GlobalSCBCCipher = Annotated[SCBCCipher, Depends(global_aes)]
